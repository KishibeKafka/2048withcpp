2048报告：
汇报人：陈友康

Alpha:
实现2048自然能想到用数组
问题就能分解为：
1、初始化棋盘
2、移动
3、生成新的数字
4、判断游戏结束
5、打印

只要循环执行后4步便构成了最简单的2048
我开始也是这么做的
用几个函数实现了以上功能
其中，在实现移动时，其实可以把四个方向、所有行列的移动归结为单行单方向的移动
所以我实现了单行向左移动和加分操作
然后用转置、对称操作以及循环，将小移动合成了大移动
值得一提的是，我还写了判断可不可以向这个方向移动的函数
只有可以移动才会扣分，不然一直输入可以把分扣完（移动还要扣分这个设定本身就很奇怪）
其他函数的实现不多赘述

Beta:
然后我们学习了动态数组，我就把原来的程序更新成了动态版本
这样游戏便可定制化，棋盘大小、生成数字概率都可以更改
基于这样的动态，我实现了四种难度（其实就是改了改棋盘大小和生成数字比例）
考虑到棋盘越小越容易暴毙，生成4和2的概率越接近越不容易合成
便有难度：
EASY:5*5,生成2的概率大于4
NORMAL:4*4,生成2的概率大于4
HARD:4*4,生成2的概率等于4
LUNATIC:3*3

1.0：
考虑到2048玩一会儿就没意思了，我决定丰富游戏内容
增加了roguelike模式
在增加这个功能的时候，回顾之前写的代码，感觉有些乱
各种函数嵌套调用，显得没有规矩
我修改了一下，尽量让函数功能唯一
然后又为rogue写了一堆代码
效果还算不错，虽然很难通关，但至少更好玩了
